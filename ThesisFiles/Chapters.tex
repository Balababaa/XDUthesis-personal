%!TEX root = ../Demo.tex


\chapter{IoC 容器}
本章介绍了Spring的Inversion of Control（IoC）容器。

\section{Spring IoC容器和Beans简介}
本章介绍了 Spring 框架是如何实现控制反转（IoC）原则的。
IoC 又称为依赖注入（DI）。
通过依赖注入，对象与对象之间的依赖关系只
通过构造
函数参数、
工厂方法参数来声明，
还可以通过属性设置方法来声明这种依赖关系，
当对象被构造函数创建或者被工厂方法创建之后，可以通过属性设置方法来设置依赖关系。
当bean被创建时，容器会把这些依赖\textit{注入}进去。
因为这个过程叫控制反转，所以它是从根本上反转了以下过程：由bean自己通过构造函数实例化或查找依赖的对象和
由bean自己通过类似服务定位模式的设计模式来实例化或查找依赖对象

org.springframework.beans 和 org.springframework.context 
这两个包是Spring 框架的IoC 容器的基础包。BeanFactory接口实现了
一种可以管理任何类型的对象的高级配置机制。
ApplicationContext 是 BeanFactory 的一个子接口。
它可以更简单的与Spring的其他功能集成：

\begin{itemize}
    \item 与Spring的AOP特性轻松集成
    \item 消息资源处理（用于国际化）
    \item 事件发布
    \item 应用层面的上下文（如用于Web 应用的WebApplicationContext）
\end{itemize}

简而言之，BeanFactory提供了配置框架和基本功能，
ApplicationContext添加了更多企业定制的功能。
ApplicationContext是BeanFactory的完整超集，本章通过它来介绍Spring的IoC容器。
如果想了解更多关于BeanFactory的使用方法，可以参考\textbf{The BeanFactory}这一节。

在 Spring 中，Bean 是指那些构成系统应用的主要对象，它们由Spring的IoC容器初始化、组装和管理。
一个Bean 只是你应用中众多对象中的一个。
Bean 包括 Bean之间的依赖关系都通过\textit{配置元数据}来定义，
这些\textit{配置元数据}会被容器使用。

\section{容器概述}
org.springframework.context.ApplicationContext接口表示Spring IoC容器，
并负责实例化，配置和组装Bean。 
容器通过读取配置元数据来获取有关要实例化，配置和组装哪些对象的指令。 
配置元数据以XML，Java注解或Java代码表示。 
它使开发者能够表达组成应用程序的对象以及这些对象之间的丰富相互依赖关系。

Spring提供了ApplicationContext接口的几种实现。 
在独立应用程序中，通常创建ClassPathXmlApplicationContext
或FileSystemXmlApplicationContext的实例。 
尽管XML是定义配置元数据的传统格式，
但是可以通过提供少量XML配置来声明性地启用对这些其他元数据格式的支持
，例如Java注解或代码。

在大多数应用场景中，不需要显式的代码来实例化一个Spring IoC容器的一个或多个实例。 
例如，在Web应用程序场景中，应用程序的web.xml文件中简单的八行（约）
模板Web描述符XML通常就足够了（请参阅Web应用程序的便捷ApplicationContext实例化）。
 如果使用Spring Tools for Eclipse（Eclipse支持的开发环境），
 则只需单击几下鼠标或击键即可轻松创建此样板配置。

 下图描绘了Spring的大致工作原理。 
 应用程序类与配置元数据会被结合在一起，
 在创建和初始化ApplicationContext之后，会产出一个完全配置且可执行的系统或应用程序。

 \begin{figure}[ht]
    \centering
    \includegraphics[width=0.6\linewidth]{./Figure/IMG_process.png}
    \caption{Spring IoC 容器}\label{Fig:xd1}
  \end{figure}

\subsection{配置元数据}
如上图所示，Spring IoC容器使用某种形式的配置元数据。 
此配置元数据表示应用程序开发人员如何告诉Spring容器实例化，配置和组装应用程序中的对象。

大多情况下，配置元数据以简单直观的XML格式提供，
因此本章大部分内容用XML格式的配置元数据来介绍Spring IoC容器的关键概念和功能。

有关在Spring容器中其他形式的元数据的使用，请参见：

\begin{itemize}
    \item 基于注解的配置：Spring 2.5引入了对基于注解的配置元数据的支持。
    \item 基于Java的配置：从Spring 3.0开始，
    Spring JavaConfig项目提供的许多功能成为核心Spring Framework的一部分。 
    因此，可以使用Java而不是XML文件来定义应用程序类外部的bean。
     要使用这些新功能，请参见@ Configuration，@ Bean，@ Import和@DependsOn注解。
\end{itemize}

Spring配置由至少一个（通常是一个以上）容器管理的bean定义组成。 
基于XML的配置元数据将这些bean配置为顶级<beans/>元素内的<bean/>元素。
Java配置通常在@Configuration类中使用@Bean注释的方法。

这些bean定义对应于组成应用程序的实际对象。
通常，开发者定义服务层对象、数据访问对象（DAO）、表示对象（例如Struts Action实例）、基础结构对象（例如Hibernate SessionFactories，JMS队列）等等。
通常，开发者不会在容器中配置细粒度的域对象，因为DAO和业务逻辑通常负责它们的创建和加载。
但是，可以使用Spring与AspectJ的集成来配置在IoC容器的控制范围之外创建的对象。
请参阅使用AspectJ与Spring依赖注入域对象。

\newpage
以下示例显示了基于XML的配置元数据的基本结构：

\begin{figure}[ht]
    \centering
    \includegraphics[width=1\linewidth]{./Figure/IMG_code_1.png}
  \end{figure}

\begin{enumerate}
    \item id属性是一个标识单个bean定义的字符串。
    \item class属性定义bean的类型，并使用完全限定的类名。
\end{enumerate}

id属性的值可以作为对象引用，并在其他bean 定义中被引用。 
在此示例中未描述如何进行对象引用。 有关更多信息，请参见依赖项。

\subsection{实例化容器}
ApplicationContext构造函数的参数是表示资源位置路径的字符串，
这些资源字符串使容器可以从各种外部资源（例如本地文件系统，Java CLASSPATH等）加载配置元数据。

\begin{figure}[ht]
\centering
\includegraphics[width=1\linewidth]{./Figure/IMG_code_2.png}
\end{figure}

\newpage
以下示例显示了服务层对象（services.xml）的配置文件：

\begin{figure}[ht]
\centering
\includegraphics[width=1\linewidth]{./Figure/IMG_code_3.png}
\end{figure}

以下示例显示了数据访问对象（daos.xml）文件：

\begin{figure}[ht]
\centering
\includegraphics[width=1\linewidth]{./Figure/IMG_code_4.png}
\end{figure}

在前面的示例中，服务层由PetStoreServiceImpl类和两个JpaAccountDao
和JpaItemDao类型的数据访问对象组成（基于JPA对象关系映射标准）。
 属性名称元素引用JavaBean属性的名称，而ref元素引用另一个bean定义的名称。 
 id和ref元素之间的这种联系表达了协作对象之间的依赖性。 
 有关配置对象的依存关系的详细信息，请参阅依存关系。

 \subsubsection{组合基于XML的配置元数据}
 使bean定义跨越多个XML文件可能会很有用。 
 通常，每个单独的XML配置文件都代表体系结构中的逻辑层或模块。

 您可以使用应用程序上下文构造函数从所有这些XML片段中加载bean定义。 
 如上一节中所示，此构造函数具有多个Resource位置。
  或者，使用一个或多个出现的<import/>元素从另一个文件中加载bean定义。 
  以下示例显示了如何执行此操作：

  \begin{figure}[ht]
    \centering
    \includegraphics[width=1\linewidth]{./Figure/IMG_code_5.png}
    \end{figure}

    在前面的示例中，外部bean定义是从以下三个文件加载的：services.xml，messageSource.xml和themeSource.xml。 
    所有位置路径都相对于进行导入的定义文件，因此，services.xml必须与进行导入的文件位于同一目录或类路径位置，
    而messageSource.xml和themeSource.xml必须位于进行导入的文件的位置下方的资源位置。 
    因此，斜杠被忽略。 但是，鉴于这些路径是相对的，最好不要使用任何斜线。 
    根据Spring Schema，导入的文件的内容（包括顶级<beans />元素）必须是有效的XML bean定义。

    命名空间本身提供了导入指令功能。 
    Spring中的一系列XML名称空间（例如，上下文和util名称空间）
    提供了超出普通bean定义的其他配置功能。

\subsubsection{Groovy Bean定义DSL}
作为外部化配置元数据的另一个示例，
Bean定义也可以在Spring的Groovy Bean定义DSL中表达，
类似Grails。 
通常，这种配置位于“.groovy”文件中，其结构如以下示例所示：

\begin{figure}[ht]
    \centering
    \includegraphics[width=1\linewidth]{./Figure/IMG_code_6.png}
\end{figure}
    
\newpage
这种配置样式在很大程度上等同于XML Bean定义，甚至支持Spring的XML配置名称空间。 
它还允许通过importBeans指令导入XML bean定义文件。

\subsection{使用容器}

ApplicationContext是高级工厂的接口，
该工厂能够维护不同bean及其依赖关系的注册表。 
通过使用方法T getBean(String name，Class <T> requiredType)，可以检索bean的实例。

ApplicationContext允许您读取bean定义并访问它们，如以下示例所示：

\begin{figure}[ht]
    \centering
    \includegraphics[width=1\linewidth]{./Figure/IMG_code_7.png}
\end{figure}

\newpage
\begin{figure}[ht]
    \centering
    \includegraphics[width=1\linewidth]{./Figure/IMG_code_8.png}
\end{figure}

使用Groovy配置也非常相似。 
它有一个不同的上下文实现类，该类可以识别Groovy（但也可以解析XML Bean定义）。
 以下示例显示了Groovy配置：

 \begin{figure}[ht]
    \centering
    \includegraphics[width=1\linewidth]{./Figure/IMG_code_9.png}
\end{figure}

最灵活的变体是将GenericApplicationContext与读取委托器结合在一起，例如，与用于XML文件的XmlBeanDefinitionReader结合使用，如以下示例所示：

\begin{figure}[ht]
    \centering
    \includegraphics[width=1\linewidth]{./Figure/IMG_code_10.png}
\end{figure}
\newpage
类似的，还可以将GroovyBeanDefinitionReader用于Groovy文件，如以下示例所示：

\begin{figure}[ht]
    \centering
    \includegraphics[width=1\linewidth]{./Figure/IMG_code_11.png}
\end{figure}

开发者可以在同一ApplicationContext上混用不用的阅读委托器来从不同的配置源读取Bean定义。

然后，可以使用getBean检索bean的实例。 
ApplicationContext接口还有其他几种检索bean的方法，
但是理想情况下，永远不要使用它们。 
实际上，您的应用程序代码应该根本不调用getBean()方法，完全不依赖于Spring API。 
例如，Spring与Web框架的集成为各种Web框架组件（如控制器和JSF托管的bean）提供了依赖注入，
开发者可以通过元数据（例如自动装配注释）声明对特定bean的依赖。

\section{Bean概述}
Spring IoC容器管理一个或多个bean。 
这些bean是使用开发者提供给容器的配置元数据创建的（例如，以XML <bean/>定义的形式）。 
在容器本身内，这些bean定义表示为BeanDefinition对象，其中包含（除其他信息外）以下元数据：

\begin{itemize}
    \item 包限定的类名：定义了Bean的实际实现类。
    \item Bean行为配置元素，用于声明Bean在容器中的行为（作用域，生命周期回调等）。
    \item 引用其他bean来完成其工作所需要的。 这些引用也称为协作者或依赖项。
    \item 要在新创建的对象中设置的其他配置设置-例如，池的大小限制或要在管理连接池的bean中使用的连接数。
\end{itemize}

此元数据转换为构成每个bean定义的一组属性。 下表描述了这些属性：

\begin{figure}[ht]
    \centering
    \includegraphics[width=1\linewidth]{./Figure/IMG_bean_def.png}
\end{figure}

除了包含有关如何创建特定bean的信息的bean定义之外，
ApplicationContext实现还允许注册在容器外部（由用户）创建的现有对象。
这是通过通过getBeanFactory()方法访问ApplicationContext的BeanFactory来完成的
，该方法返回BeanFactory DefaultListableBeanFactory实现。
DefaultListableBeanFactory通过registerSingleton(..)和registerBeanDefinition(..)
方法支持此注册。 但是，典型的应用程序只能与通过常规bean定义元数据定义的bean一起使用。

\subsection{Bean命名}

每个bean具有一个或多个标识符。 这些标识符在承载Bean的容器内必须是唯一的。 
一个bean通常只有一个标识符。 
但是，如果有多个，则将其余的视为别名。

在基于XML的配置元数据中，可以使用id属性和name属性来指定bean标识符。
id属性可以精确指定一个id。 
通常，这些名称是字母数字（“ myBean”，“ someService”等），
但它们也可以包含特殊字符。 如果要为bean引入其他别名，
还可以在name属性中指定它们，并用逗号，分号或空格分隔。 
在Spring 3.1之前的版本中，id属性定义为xsd：ID类型，该类型限制了可能的字符。
从3.1开始，它被定义为xsd：string类型。 
但是，bean ID唯一性仍由容器强制执行，尽管不再由XML解析器执行。

开发者不需要提供Bean的名称或ID。 
如果未明确提供名称或ID，则容器将为该bean生成一个唯一的名称。 
但是，如果要通过使用ref元素或服务定位器样式引用该bean，则必须提供一个名称。
不提供名称一般在使用内部bean和自动装依赖情况下存在。


\subsubsection{在Bean定义之外定义Bean的别名}
在bean定义中，可以使用id属性和name实现来定义多个bean名称。
这些名称可以是同一个bean的等效别名，并且在某些情况下很有用，
例如通过使用特定于该组件本身的bean名称，让应用程序中的每个组件都引用一个公共依赖项。

但是，在实际定义bean的地方指定所有别名并不总是足够的。 
有时需要为在别处定义的bean引入别名。 
在大型系统中，配置定义在每个子系统中，每个子系统都有自己的对象定义集。 
在基于XML的配置元数据中，可以使用<alias />元素来完成此操作。 
以下示例显示了如何执行此操作：

\begin{figure}[ht]
    \centering
    \includegraphics[width=1\linewidth]{./Figure/IMG_code_12.png}
\end{figure}
在上面的例子中，
在使用该别名定义之后，
名为fromName的bean（在同一容器中）也就是toName。

例如，子系统A的配置元数据可以通过subsystemA-dataSource的名称引用数据源。 
子系统B的配置元数据可以通过subsystemB-dataSource的名称引用数据源。 
组成使用这两个子系统的主应用程序时，主应用程序通过myApp-dataSource的名称引用数据源。
要使所有三个名称都引用相同的对象，可以将以下别名定义添加到配置元数据中：

\begin{figure}[ht]
    \centering
    \includegraphics[width=1\linewidth]{./Figure/IMG_code_13.png}
\end{figure}

\section{Bean 实例化}
Bean定义本质上是创建一个或多个对象的基础数据。 
当bean被需要时，容器将查找对应的bean定义，
并使用该bean定义封装的配置元数据来创建（或获取）实际对象。

如果使用基于XML的配置元数据，则在<bean />元素的class属性中指定要实例化的对象的类型（或类）。 
这个class属性（在内部是BeanDefinition实例的Class属性）通常是必需的。 
（有关异常，请参阅使用实例工厂方法实例化和Bean定义继承。）
可以通过以下两种方式之一使用Class属性：

\begin{itemize}
    \item 通常，指定要构造的Bean类，在容器本身通过反射性地调用其构造函数直接创建Bean的情况下，这在某种程度上等同于使用new运算符的Java代码。
    \item 要指定包含用于创建对象的静态工厂方法的实际类，在不太常见的情况下，容器将在类上调用静态工厂方法以创建Bean。 从静态工厂方法的调用返回的对象类型可以是同一类，也可以是完全不同的另一类。
\end{itemize}

\subsubsection{使用构造函数实例化}
当通过构造函数方法创建bean时，所有普通类都可以被Spring使用并与之兼容。 
也就是说，正在开发的类不需要实现任何特定的接口或以特定的方式进行编码。 
只需指定bean类就足够了。 但是可能需要一个默认（空）构造函数。

Spring IoC容器几乎可以管理任何类，不仅限于管理真正的JavaBean。 
大多数Spring用户更喜欢实际的JavaBean，
它仅具有默认（无参数）构造函数，并具有根据容器中的属性建模的适当的setter和getter。 
还可以在容器中拥有更多奇特的非Bean风格的类，例如，如果需要使用绝对不符合JavaBean规范的旧式连接池，
Spring也可以对其进行管理。

使用基于XML的配置元数据，可以如下指定bean类：

\begin{figure}[ht]
    \centering
    \includegraphics[width=1\linewidth]{./Figure/IMG_code_14.png}
\end{figure}

有关向构造函数提供参数（如果需要）并在构造对象之后设置对象实例属性的机制的详细信息，请参见\textbf{依赖注入}。

\subsubsection{使用静态工厂方法实例化}
定义使用静态工厂方法创建的bean时，请使用class属性指定包含静态工厂方法的类，
并使用名为factory-method的属性指定工厂方法本身的名称。 
程序应该能够调用此方法（后面解释带有可选参数的情况），并返回一个活动对象，
该对象随后将被视为已通过构造函数创建。 
这种bean定义的一种用法是在旧版代码中调用静态工厂。

以下bean定义指定通过调用工厂方法来创建bean。 
这种定义不能指定返回对象的类型（类），仅能指定包含工厂方法的类。  以下示例显示如何指定工厂方法，
在此示例中，createInstance()方法必须是静态方法：

\begin{figure}[ht]
    \centering
    \includegraphics[width=1\linewidth]{./Figure/IMG_code_15.png}
\end{figure}

以下示例显示了需要与前面的bean定义一起使用的类：

\begin{figure}[ht]
    \centering
    \includegraphics[width=1\linewidth]{./Figure/IMG_code_16.png}
\end{figure}

有关为工厂方法提供（可选）参数并在从工厂返回对象后设置对象实例属性的机制的详细信息，
请参阅详细信息中的\textbf{依赖关系}和\textbf{配置}。

\subsubsection{使用实例工厂方法实例化}
类似于通过静态工厂方法进行实例化，
使用实例工厂方法进行实例化会从容器中调用现有bean的非静态方法来创建新bean。 
要使用此机制，请将class属性保留为空，并在factory-bean属性中，
在当前（或父或祖先）容器中指定包含要创建该对象的实例方法的Bean的名称。 
使用factory-method属性设置工厂方法本身的名称。 以下示例显示了如何配置此类Bean：

\begin{figure}[ht]
    \centering
    \includegraphics[width=1\linewidth]{./Figure/IMG_code_17.png}
\end{figure}

以下示例显示了相应的类：

\begin{figure}[ht]
    \centering
    \includegraphics[width=1\linewidth]{./Figure/IMG_code_18.png}
\end{figure}

\newpage
一个工厂类也可以包含一个以上的工厂方法，如以下示例所示：

\begin{figure}[ht]
    \centering
    \includegraphics[width=1\linewidth]{./Figure/IMG_code_19.png}
\end{figure}

\newpage
以下示例显示了相应的类：
\begin{figure}[ht]
    \centering
    \includegraphics[width=1\linewidth]{./Figure/IMG_code_20.png}
\end{figure}

这种方法表明，工厂Bean本身可以通过依赖项注入（DI）进行管理和配置。 
详细信息，请参见\textbf{依赖和配置}。

\subsubsection{确定Bean的运行时类型}
确定特定bean的运行时类型并非易事。
 Bean元数据定义中的指定类只是初始类引用，
 可能与声明的工厂方法结合使用，或者是FactoryBean类，
 这可能导致Bean的运行时类型不同，或者在实例工厂方法的情况下完全不进行设置（通过指定的factory-bean名称解析）。
此外，AOP代理可以使用基于接口的代理包装bean实例，
而目标Bean的实际类型（仅是其接口的实现类）的暴露程度有限。

找出特定bean的实际运行时类型的推荐方法是对指定bean名称的BeanFactory.getType调用。 
这考虑了上述所有情况，并返回了与BeanFactory.getBean相同的对象类型。

\section{依赖}
典型的企业应用程序不包含单个对象（或Spring术语中的bean）。 即使是最简单的应用程序，也有一些对象可以协同工作，以呈现最终用户视为一致的应用程序。 下一部分将说明如何从定义多个独立的bean定义到实现对象协作以实现目标的完全实现的应用程序。

\subsection{依赖注入}

依赖注入（DI）是一个过程，
通过该过程，对象只能通过构造函数参数，
工厂方法的参数或在构造或创建或从工厂方法返回对象实例后在对象实例上设置的属性来定义其依赖关系
（即，与它们一起工作的其他对象）。 然后，容器在创建bean时注入那些依赖项。 
此过程从根本上讲是通过使用类的直接构造或服务定位器模式来控
制其自身的实例化或位置的Bean本身的逆过程（因此称为控制反转）。

使用DI原理，代码更简洁，
当为对象提供依赖项时，去耦会更有效。 
该对象不查找其依赖项，并且不知道依赖项的位置或类。 
因此类变得更易于测试，尤其是当依赖项依赖于接口或抽象基类时，
它们允许在单元测试中使用存根或模拟实现。

DI存在两个主要变体：基于构造函数的依赖注入和基于Setter的依赖注入。

\subsubsection{基于构造函数的依赖注入}
基于构造函数的DI是通过容器调用具有多个参数（每个参数代表一个依赖项）的构造函数来完成的。 调用带有特定参数的静态工厂方法来构造Bean几乎是等效的，并且本次讨论将构造函数和静态工厂方法的参数视为类似。 以下示例显示了只能通过构造函数注入进行依赖项注入的类：

\newpage
\begin{figure}[ht]
    \centering
    \includegraphics[width=1\linewidth]{./Figure/IMG_code_21.png}
\end{figure}

注意，该类没有什么特别的。 它是一个POJO，不依赖于特定于容器的接口，基类或注解。

\newpage
\textbf{构造函数参数解析} 构造函数参数解析匹配是通过使用参数的类型进行的。 如果Bean定义的构造函数参数中没有潜在的歧义，则在实例化Bean时，在Bean定义中定义构造函数参数的顺序就是将这些参数提供给适当的构造函数的顺序。 考虑以下类：

\begin{figure}[ht]
    \centering
    \includegraphics[width=1\linewidth]{./Figure/IMG_code_22.png}
\end{figure}
\begin{figure}[ht]
    \centering
    \includegraphics[width=1\linewidth]{./Figure/IMG_code_23.png}
\end{figure}

假设ThingTwo和ThingThree类没有通过继承关联，则不存在潜在的歧义。 因此，以下配置可以正常工作，并且无需在<constructor-arg />元素中显式指定构造函数参数索引或类型。

\begin{figure}[ht]
    \centering
    \includegraphics[width=1\linewidth]{./Figure/IMG_code_24.png}
\end{figure}

\newpage
当引用另一个bean时，类型是已知的，并且可以发生匹配（与前面的示例一样）。 当使用简单类型（例如<value> true </ value>）时，Spring无法确定值的类型，因此在没有帮助的情况下无法按类型进行匹配。 考虑以下类：
\begin{figure}[ht]
    \centering
    \includegraphics[width=1\linewidth]{./Figure/IMG_code_25.png}
\end{figure}

\begin{figure}[ht]
    \centering
    \includegraphics[width=1\linewidth]{./Figure/IMG_code_26.png}
\end{figure}

在上述情况下，如果通过使用type属性显式指定构造函数参数的类型，则容器可以使用简单类型的类型匹配，如以下示例所示：

\begin{figure}[ht]
    \centering
    \includegraphics[width=1\linewidth]{./Figure/IMG_code_27.png}
\end{figure}

\newpage
可以使用index属性来显式指定构造函数参数的索引，如以下示例所示：

\begin{figure}[ht]
    \centering
    \includegraphics[width=1\linewidth]{./Figure/IMG_code_28.png}
\end{figure}

除了解决多个简单值的歧义性之外，当构造函数具有两个相同类型的参数时，指定索引还可以解决歧义。

还可以使用构造函数参数名称来消除歧义，如以下示例所示：

\begin{figure}[ht]
    \centering
    \includegraphics[width=1\linewidth]{./Figure/IMG_code_29.png}
\end{figure}

请记住，要立即使用该功能，必须在启用调试标志的情况下编译代码，以便Spring可以从构造函数中查找参数名称。 如果您不能或不想使用debug标志编译代码，则可以使用@ConstructorProperties JDK注释显式命名构造函数参数。 类必须如下所示：

\begin{figure}[ht]
    \centering
    \includegraphics[width=1\linewidth]{./Figure/IMG_code_30.png}
\end{figure}

\newpage
\subsubsection{基于Setter的依赖注入}
通过调用无参数构造函数或无参数静态工厂方法以实例化的bean之后，容器通过在bean上调用setter方法来完成基于setter的DI。

下面的示例显示只能通过使用纯setter注入来进行依赖项注入的类。 此类是常规的Java。 它是一个POJO，不依赖于特定于容器的接口，基类或注解。

\begin{figure}[ht]
    \centering
    \includegraphics[width=1\linewidth]{./Figure/IMG_code_31.png}
\end{figure}

ApplicationContext为它管理的bean提供基于构造函数和基于setter的DI。
在通过构造函数方法注入了一些依赖项之后，它还支持基于setter的DI。
您可以以BeanDefinition的形式配置依赖项，与PropertyEditor实例一起使用，
将属性从一种格式转换为另一种格式。
但是，大多数Spring用户并不是直接使用这些类(即通过编程方式)，而
是使用XML bean定义、带注解的组件(即使用@Component、@Controller等带注解的类)，
或者基于java的@Configuration类中的@Bean方法。然后，这些源在内部转换为BeanD
efinition的实例，并用于加载整个Spring IoC容器实例。

\textbf{依赖性解析过程} 容器按照如下方式执行bean依赖项解析：

\begin{itemize}
    \item 使用描述所有bean的配置元数据创建和初始化ApplicationContext。 可以通过XML，Java代码或注解来指定配置元数据。
    \item 对于每个bean，它的依赖关系以属性、构造函数参数或静态工厂方法的参数的形式表示(如果您使用静态工厂方法而不是普通构造函数)。当实际创建bean时，这些依赖项被提供给bean。
    \item 每个属性或构造函数参数都是要设置的值的实际定义，或对容器中另一个bean的引用。
    \item 作为值的每个属性或构造函数参数都将从其指定的格式转换为该属性或构造函数参数的实际类型。默认情况下，Spring可以将字符串格式提供的值转换为所有内置类型，比如int、long、string、boolean等等。
\end{itemize}

Spring容器在创建容器时验证每个bean的配置。
但是，在实际创建bean之前，不会设置bean属性本身。
单例作用域和设置为预实例化(默认)的bean会在容器被创建时是同步创建。
作用域在Bean作用域中定义。
其他类型的bean仅在请求时创建。
创建一个bean可能会导致创建多个bean
，因为需要创建bean的依赖项及其依赖项的依赖项(等等)。
请注意，这些依赖项之间的解析不匹配可能会在之后出现——即在受影响bean的第一次创建时出现。

您通常可以相信Spring会做正确的事情。
它在容器加载时检测配置问题，比如对不存在的bean和循环依赖项的引用。
当bean实际创建时，Spring会尽可能晚地设置属性并解析依赖项。
这意味着，如果在创建对象或其某个依赖项时出现问题，已经正确加载的Spring容器可以生成异常——例如，
bean会由于缺少或无效的属性而抛出异常。这可能会延迟一
些配置问题的可见性，这就是为什么ApplicationContext实
现默认情况下会预先实例化单例bean。在实际需要这些bean之前
创建这些bean需要花费一些前期时间和内存，但是在创建Appli
cationContext时就可以发现配置问题。
这个默认行为可以被覆盖，使单例bean的初始化延迟。

如果不存在循环依赖项，那么当一个或多个协作bean被注入到依赖bean中时，
每个协作bean在被注入到依赖bean之前都会被完全配置。这
意味着，如果bean A依赖于bean B, Spring IoC容器在调用bean A
的setter方法之前完全配置bean B。换句话说，当bean已经被实例化(如果它不
是一个预实例化的单例)，那么它的依赖项就已经被设置，并且相关的生命周期方法也已经被调用
(例如配置的init方法或InitializingBean回调方法)。

\subsection{依赖和配置的细节}
如上一节所述，您可以将bean属性和构造函数参数定义为对其他托管bean（协作者）的引用，也可以定义为内联定义的值。 Spring的基于XML的配置元数据为此目的在其<property />和<constructor-arg />元素中支持子元素类型。

\subsubsection{常量(原始类型、字符串等)}

</property>元素的value属性将属性或构造函数参数指定为人类可读的字符串表示形式。Spring的转换服务用于将这些值从String转换为属性或参数的实际类型。下面的示例显示了正在设置的各种值:

\begin{figure}[ht]
    \centering
    \includegraphics[width=1\linewidth]{./Figure/IMG_code_32.png}
\end{figure}

下面的例子使用p-namespace来进行更简洁的XML配置:

\begin{figure}[ht]
    \centering
    \includegraphics[width=1\linewidth]{./Figure/IMG_code_33.png}
\end{figure}

前面的XML更简洁。然而，输入错误只能在运行时被发现，除非使用支持创建bean定义时自动完成属性的IDE(如IntelliJ IDEA或用于Eclipse的Spring Tools)。强烈推荐这样的IDE帮助。

您也可以配置一个java.util.Properties实例，如下所示:


\begin{figure}[ht]
    \centering
    \includegraphics[width=1\linewidth]{./Figure/IMG_code_34.png}
\end{figure}

通过使用JavaBeans的PropertyEditor机制，Spring容器将<value></value>元素中的文本
转换为java.util.Properties实例。这是一个很好的快捷方式，也是
Spring团队喜欢使用嵌套<value></value>元素而不是value属性样式的少数地方之一。

idref元素只是将容器中另一个bean的id(字符串值——而不是引用)传递给<constructor-arg>或</property>元素的一种防止错误的方法。</constructor-arg>下面的例子展示了如何使用它:

\begin{figure}[ht]
    \centering
    \includegraphics[width=1\linewidth]{./Figure/IMG_code_35.png}
\end{figure}

前面的bean定义片段(在运行时)与下面的片段完全相同:

\begin{figure}[ht]
    \centering
    \includegraphics[width=1\linewidth]{./Figure/IMG_code_36.png}
\end{figure}

第一种形式比第二种形式更可取，因为使用idref标
记可以让容器在部署时验证所引用的已命名bean实际存在。
在第二个变体中，对传递给目标bean的targetName属性的值不执行任何验证。
只有在实际实例化目标bean时才会发现错误(很可能导致致命的结果)。如果目标bean是一个原型bean
，那么这个输入错误和由此产生的异常可能要在容器部署很久之后才会被发现。

<idref></idref>元素的一个常见地方(至少在Spring 2.0之前的版本中)
是在ProxyFactoryBean bean定义中的AOP拦截器配置中。在指定拦截器名称时
使用<idref></idref>元素可以防止拼错写错误。

\subsection{对其他bean(合作者)的引用}
ref元素是<constructor-arg>或</property>定义元素中的最后一个元素。
您将一个bean的指定属性的值设置为对容器管
理的另一个bean(合作者)的引用。被引用的bean是要设置其属性的bean的依赖
项，在设置属性之前，根据需要对其进行初始化。(如果合作者是一个单例bean，
它可能已经被容器初始化了。)所有引用最终都是对另一个对象的引用。范围和验
证取决于您是通过bean还是父属性指定其他对象的ID或名称。

通过<ref></ref>标记bean属性来指定目标bean是最通用的形式，
允许在同一容器或父容器中创建对任何bean的引用，
而不管它是否在同一XML文件中。
bean属性的值可以与目标bean的id属性相同，
也可以与目标bean的name属性中的某个值相同。
下面的例子展示了如何使用ref元素:

\begin{figure}[ht]
    \centering
    \includegraphics[width=1\linewidth]{./Figure/IMG_code_37.png}
\end{figure}

通过parent属性指定目标bean将创建对当前容器父容器中的bean的引用。
parent属性的值可以与目标bean的id属性或目标bean的name属性中的一个值相同。
目标bean必须位于当前bean的父容器中。
当您有一个容器层次结构，并且您想用与父容器中的bean同名的代理将现有它包装时，
您应该主要使用这个bean引用变体。下面的两个清单显示了如何使用parent属性:

\begin{figure}[ht]
    \centering
    \includegraphics[width=1\linewidth]{./Figure/IMG_code_38.png}
\end{figure}

\begin{figure}[ht]
    \centering
    \includegraphics[width=1\linewidth]{./Figure/IMG_code_39.png}
\end{figure}

\chapter{Spring中的面向切面编程}
面向切面编程是面向对象编程的补充，它提出了另一种对程序结构的思考方式。
在OOP中，最重要的模块是类，而在AOP中，最重要的模块是\textit{切面}。
切面使程序的关注点模块化，例如可以通过AOP实现跨多种类型和对象的事务管理
（这类关注点在关于AOP的文献中通常被称为横切关注点）。

AOP 框架是Spring中最重要的组件之一。
AOP组件并不和Spring的IoC 容器强绑定，你可以在不引入AOP的情况下使用容器。
AOP为 Sping的IoC提供一种非常强大的中间件解决方案。

在Spring框架中，AOP常被用于：

\begin{itemize}
    \item 提供声明式的企业服务，最重要的此类服务是声明式事务。
    \item 允许开发者实现自定义的切面来使用AOP扩展OOP。
\end{itemize}

\section{AOP中的概念}
首先介绍一下在AOP中的一些主要概念和术语。
这些概念和术语并不是Spring定义的，不过它们含义并不是很特别直观。
如果由Spring使用自己的概念和术语，可能反而会令开发者更加困惑。

\begin{itemize}
    \item 切面：可以涉及不同类的模块化关注点。 事物管理是
    企业Java应用程序中横切关注点的一个很好的例子。 在Spring AOP中，切面
    使用常规类（基于配置声明的方式）或@Aspect带注释的常规类实现
    （基于@AspectJ的方式）。
    \item 连接点：程序执行过程中的某一时刻，例如方法执行或异常处理。
     在Spring AOP中，连接点始终是方法执行。
    \item 增强：切面在某个连接点执行的操作，有前置、后置、环绕等增强方式（下文介绍）。
    在包括Spring在内的众多AOP框架中，
    都会将增强实现为一个拦截器，然后将多个拦截器组装成一个作用于连接点的拦截器链。
    \item 切点：是一个谓词表达式，用来计算是否匹配连接点。
    增强与切点表达式相关联
    并切会在匹配切点表达式的连接点上执行（例如，指定匹配特定名称的方法）。
    被切入点表达式匹配的连接点是AOP的核心概念。
    默认情况下，Spring使用AspectJ切点表达语言。
    \item 引入：在个对象中声明额外的方法或字段。
    Spring AOP允许开发者向被增强的对象引入新的接口以及对应的实现。
    例如，开发者可以使用引入来使Bean实现IsModified接口，以简化缓存。
    （在AspectJ社区中，引入也被称为跨类型声明）
    \item 目标对象：被一个或多个切面增强的对象，即“被增强对象”。
    由于Spring AOP是使用运行时代理实现的，因此对象始终是被代理对象。
    \item AOP 代理：AOP框架为了实现切面（增强方法执行等）而创建的对象。在Spring框架中，一个AOP 代理对象要么是JDK动态代理创建的，要么是GCLIB创建的。
    \item 织入：将切面与其他类型或对象链接以创建一个被增强对象的过程。织入可以在编译时（使用AspectJ 编译器）、加载时和运行时执行。
    像其他纯Java实现的AOP框架一样，Spring AOP 在运行时完成织入。
\end{itemize}

增强的种类：

\begin{itemize}
    \item 前置增强：在连接点之前执行增强，但是并不能阻碍连接点之后的程序执行，除非在增加执行的过程中抛出异常。
    \item 返回后增强：在连接点正常执行完成之后执行增强，比如，一个方法正常执行完成而且没有抛出异常。
    \item 抛异常后增强：在连接点执行抛出异常之后执行增强。
    \item 后置增强：不论连接点是否正常执行完成，都会在之后执行增强。
    \item 环绕增强：环绕连接点（例如方法执行）执行的增强，是最强大的增强类型。
    环绕增强可以在方法执行之前和执行完成之后执行定制化的逻辑。因此它还能控制是否继续执行连接点之后的代码，
    可以选择抛出异常、返回连接点的执行结果或者返回增强自己的结果。
\end{itemize}

环绕增强建议是最通用的增强。
Spring AOP与AspectJ一样，提供了各种增强类型，
因此我们建议开发者使用功能最弱的建议类型来实现所需的额外操作。
例如，如果只需要用方法的返回值来更新缓存，
则最好使用返回后增强而不是环绕增强，尽管环绕增强可以完成相同的事情。
使用最合适的增强类型可以使编程模型更简单，并减少出错的可能性。
例如，开发者不需要在环绕增强的JoinPoint上调用proceeed()方法，所以也不会导致调用失败。

所有增强的参数都是静态类型的，
因此开发者可以使用参数的确切类型（例如，方法返回的值的类型）而不是对象数组类型。

匹配切点的连接点是AOP的关键概念，它与仅提供拦截功能的旧技术有所不同。
切点使增强独立于面向对象的层次结构中。
例如，开发者可以将提供声明性事务管理的环绕增强应用于多个对象（例如服务层中的所有业务操作）的一组方法。

\section{Spring AOP能力和目标}
Spring AOP是用纯Java实现的。 不需要特殊的编译过程。 
Spring AOP不需要控制类加载器的层次结构，因此适合在Servlet容器或应用程序服务器中使用。

Spring AOP当前仅支持方法执行连接点（增强在Spring Bean上执行方法）。
尽管可以在不破坏核心Spring AOP API的基础上添加对字段侦听的支持，但是目前暂未实现。
如果需要增强字段的访问和更新的连接点，可以考虑使用诸如AspectJ之类的语言。

Spring AOP的实现方法不同于大多数其他AOP框架。 
其目的不是提供最完整的AOP实现（尽管Spring AOP相当强大），
而是在AOP实现和Spring IoC之间提供紧密的集成，以帮助解决企业应用程序中的常见问题。

因此，通常将Spring 框架的AOP功能与IoC容器结合使用。
通过使用常规bean定义语法来配置切面（强大的“自动代理”功能）。
这是与其他AOP实现的关键区别。
使用Spring AOP有时候无法轻松或高效地完成某些事情，例如增强非常细粒度的对象（通常是域对象）。
在这种情况下，AspectJ是最佳选择。
但是，大部分情况下，Spring AOP为
AOP可以解决的企业Java应用程序中的大多数问题
提供了出色的解决方案。

Spring AOP从未在提供全面的AOP解决方案上与AspectJ竞争。
 我们认为，基于代理的框架（例如Spring AOP）和成熟的框架（例如AspectJ）都是有价值的，
 并且它们是互补的，而不是竞争。 
 Spring无缝地将Spring AOP和IoC与AspectJ集成在一起，
 使得在基于Spring的一致应用程序架构中支持AOP的所有使用。
  这种集成不会影响Spring AOP API或AOP Alliance API。
   Spring AOP保持向后兼容。 有关Spring AOP API的讨论，请参见下一章。

\section{AOP代理}
Spring AOP默认使用标准JDK动态代理实现AOP代理，因此可以代理任何接口（或一组接口）。

Spring AOP也可以使用CGLIB代理。 
在需要对类进行代理的情况下，基于CGLIB的代理是必须的。 
默认情况下，如果业务对象未实现接口，则使用CGLIB。 
面向接口编程是行业规范，因此业务类通常实现一个或多个业务接口。 
当需要增强未在接口上声明的方法或需要将代理对象作为具体类型传递给方法的情况下（在极少数情况下），
可以强制使用CGLIB。

掌握Spring AOP是基于代理实现的这一事实是非常重要。 
要了解具体实现细节，请参阅了解AOP代理。